# Chat Context Refactoring

## Проблема
Ранее в приложении использовался хук `useMultipleChats` в двух экранах (chat и scan), что приводило к конфликтам WebSocket соединений. Каждый экран создавал свое собственное подключение, из-за чего при переходе между экранами чат переставал работать корректно.

Дополнительно была проблема с переключением чатов - при выборе чата из истории он переключался на миг и возвращался обратно из-за конфликта между выбранным чатом и автоматическим подключением к API данным.

## Решение
1. Создан глобальный `ChatContext`, который управляет единым WebSocket соединением для всего приложения
2. Полностью удален `useMultipleChats` хук
3. Исправлена логика переключения чатов с добавлением флага `userSelectedChat`

## Изменения

### 1. Новый файл: `client/context/ChatContext.tsx`
- Создан глобальный контекст для управления чатом
- Содержит единое WebSocket соединение
- Автоматически подключается при наличии токена
- Поддерживает соединение между переходами по экранам
- Упрощен код, убраны лишние логи

### 2. Обновлен: `client/app/(tabs)/_layout.tsx`
- Добавлен `ChatProvider` для оборачивания всех табов
- Передается токен пользователя в провайдер
- Добавлена обработка ошибок чата

### 3. Обновлен: `client/app/(tabs)/chat.tsx`
- Заменен `useMultipleChats` на `useChat` из контекста
- Добавлен флаг `userSelectedChat` для отслеживания ручного выбора чата
- Исправлена логика автоподключения - теперь не конфликтует с выбором из истории
- Улучшена логика отображения сообщений с проверкой соответствия ID
- Убраны лишние логи

### 4. Обновлен: `client/app/(tabs)/scan.tsx`
- Заменен `useMultipleChats` на `useChat` из контекста
- Использует тот же WebSocket что и экран чата
- Убрано создание дублирующих подключений
- Упрощен код, убраны лишние логи

### 5. Удален: `client/hooks/useMultipleChats.ts`
- Хук полностью удален как более не нужный
- Все компоненты теперь используют `useChat` напрямую

## Исправленные проблемы

### Переключение чатов
**Проблема**: При выборе чата из истории он переключался на миг и возвращался обратно.

**Причина**: Конфликт между:
- Выбранным чатом из истории (`handleSelectChat`)
- Автоматическим подключением к чату из API (`useGetUserOneChatQuery`)

**Решение**: 
- Добавлен флаг `userSelectedChat` для отслеживания ручного выбора
- Автоподключение к API данным происходит только если пользователь не выбрал чат вручную
- Добавлены проверки соответствия ID при отображении сообщений

### Дублирующие подключения
**Проблема**: Каждый экран создавал свое WebSocket соединение.

**Решение**: Единое соединение в `ChatContext`, используемое всеми экранами.

## Преимущества

1. **Единое подключение**: Только одно WebSocket соединение для всего приложения
2. **Бесшовные переходы**: Чат продолжает работать при переходе между экранами
3. **Корректное переключение**: Выбор чата из истории работает без конфликтов
4. **Лучшая производительность**: Нет дублирующих подключений
5. **Централизованное управление**: Все состояние чата в одном месте
6. **Простота кода**: Убраны избыточные абстракции и логи

## Архитектура

```
TabsLayout (ChatProvider)
├── ChatScreen (useChat) - с логикой переключения чатов
├── ScanScreen (useChat) - использует текущий активный чат
└── Other screens
```

## API

### ChatContext
```typescript
interface ChatContextType {
  isConnected: boolean;
  isConnecting: boolean;
  currentChat: ChatState;
  sendMessage: (message: string) => void;
  createChat: () => void;
  joinChat: (chatId: string) => void;
  switchChat: (chatId: string) => void;
  connect: () => Promise<void>;
  disconnect: () => void;
}
```

### Использование
```typescript
// В компоненте
const { isConnected, currentChat, sendMessage, joinChat } = useChat();

// Отправка сообщения
sendMessage("Hello!");

// Подключение к чату
joinChat("chat-id");
```

## Миграция

Для существующих компонентов:
- Заменить `useMultipleChats` на `useChat`
- Убрать параметры `token` и `onError` (теперь в провайдере)
- Остальной код остается без изменений

## Логика переключения чатов

1. **Автоподключение**: Если пользователь не выбрал чат вручную, автоматически подключается к чату из API
2. **Ручной выбор**: При выборе из истории устанавливается флаг `userSelectedChat`
3. **Отображение**: Показываются сообщения только соответствующие выбранному чату
4. **Создание нового**: При создании нового чата также устанавливается флаг ручного выбора 